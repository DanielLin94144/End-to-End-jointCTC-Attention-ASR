
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/SpecAugment.ipynb

from collections import namedtuple
import random

import torch
import torchaudio
from torchaudio import transforms
from nb_SparseImageWarp import sparse_image_warp
import matplotlib.pyplot as plt
import math
from IPython.display import Audio

#from torchaudio.transforms import freq_mask, time_mask, time_warp

class Augment(torch.jit.ScriptModule):
    def __init__(self,spec, T=40, num_masks=1, replace_with_zero=False, F=30):
        super(Augment, self).__init__()    
    self.T=T
    self.num_masks=num_masks
    self.replace_with_zero=replace_with_zero
    self.F=F

    @torch.jit.script_method
    def forward(self, spec):
        tmasked = time_mask(spec, T=self.T, num_masks=self.num_masks,, replace_with_zero=self.replace_with_zero)
        ftmasked = freq_mask(tmasked, F=self.F, num_masks=self.num_masks, replace_with_zero=self.replace_with_zero)
        return ftmasked

    def time_mask(spec, T=40, num_masks=1, replace_with_zero=False):
        cloned = spec.clone()
        len_spectro = cloned.shape[2]

        for i in range(0, num_masks):
            t = random.randrange(0, T)
            t_zero = random.randrange(0, len_spectro - t)

            # avoids randrange error if values are equal and range is empty
            if (t_zero == t_zero + t): return cloned

            mask_end = random.randrange(t_zero, t_zero + t)
            if (replace_with_zero): cloned[0][:,t_zero:mask_end] = 0
            else: cloned[0][:,t_zero:mask_end] = cloned.mean()
        return cloned

    def freq_mask(spec, F=30, num_masks=1, replace_with_zero=False):
    cloned = spec.clone()
    num_mel_channels = cloned.shape[1]

    for i in range(0, num_masks):
        f = random.randrange(0, F)
        f_zero = random.randrange(0, num_mel_channels - f)

        # avoids randrange error if values are equal and range is empty
        if (f_zero == f_zero + f): return cloned

        mask_end = random.randrange(f_zero, f_zero + f)
        if (replace_with_zero): cloned[0][f_zero:mask_end] = 0
        else: cloned[0][f_zero:mask_end] = cloned.mean()
        #print(cloned.mean())

    return cloned

    def tensor_to_img(spectrogram, filename):
        spectrogram = to_db_scale(spectrogram)
        spectrogram = spectrogram.detach().numpy()
        print(spectrogram[0])
        plt.figure(figsize=(14,1)) # arbitrary, looks good on my screen.
        plt.imshow(spectrogram[0][:][:])
        plt.savefig(filename)
        #plt.show()
        #display(spectrogram.shape)

    def time_warp(spec, W=5):
        num_rows = spec.shape[1]
        spec_len = spec.shape[2]
        device = spec.device

        y = num_rows//2
        horizontal_line_at_ctr = spec[0][y]
        assert len(horizontal_line_at_ctr) == spec_len

        point_to_warp = horizontal_line_at_ctr[random.randrange(W, spec_len - W)]
        assert isinstance(point_to_warp, torch.Tensor)

        # Uniform distribution from (0,W) with chance to be up to W negative
        dist_to_warp = random.randrange(-W, W)
        src_pts, dest_pts = (torch.tensor([[[y, point_to_warp]]], device=device),
                            torch.tensor([[[y, point_to_warp + dist_to_warp]]], device=device))
        warped_spectro, dense_flows = sparse_image_warp(spec, src_pts, dest_pts)
        return warped_spectro.squeeze(3)

    def test_time_warp():
        tensor_to_img(time_warp(spectro))
        tensor_to_img(spectro)    



    def test_freq_mask():
        tensor_to_img(freq_mask(spectro))
        # Two Masks...
        tensor_to_img(freq_mask(spectro, num_masks=2))
        # with zeros
        tensor_to_img(freq_mask(spectro, num_masks=2, replace_with_zero=True))

    def time_mask(spec, T=40, num_masks=1, replace_with_zero=False):
        cloned = spec.clone()
        len_spectro = cloned.shape[2]

        for i in range(0, num_masks):
            t = random.randrange(0, T)
            t_zero = random.randrange(0, len_spectro - t)

            # avoids randrange error if values are equal and range is empty
            if (t_zero == t_zero + t): return cloned

            mask_end = random.randrange(t_zero, t_zero + t)
            if (replace_with_zero): cloned[0][:,t_zero:mask_end] = 0
            else: cloned[0][:,t_zero:mask_end] = cloned.mean()
        return cloned

    def test_time_mask():
        tensor_to_img(time_mask(spectro))
        # Two Masks...
        tensor_to_img(time_mask(spectro, num_masks=2))
        # with zeros
        tensor_to_img(time_mask(spectro, num_masks=2, replace_with_zero=True))

    def tfm_spectro(ad, sr):
        # We must reshape signal for torchaudio to generate the spectrogram.
        ws=512
        hop=256
        to_db_scale=False
        n_fft=1024
        f_min=0.0
        f_max=-80 
        pad=0
        n_mels=128
        #mel = transforms.MelSpectrogram(sr, n_mels=n_mels, n_fft=n_fft, hop=hop, f_min=f_min, f_max=f_max, pad=pad)(ad)
        sp = transforms.Spectrogram()(ad)
        mel = transforms.MelScale()(sp)
        #mel = mel.permute(0,2,1) # swap dimension, mostly to look sane to a human.
        #if to_db_scale: mel = transforms.SpectrogramToDB(stype='magnitude', top_db=f_max)(mel)
        #mel = mel.detach().numpy()
        if to_db_scale: 
            mel = 20*torch.log10(mel)
        return mel

    def to_db_scale(spectrogram):
        db_sp = 20*torch.log10(spectrogram)
        return db_sp
    '''
    sample = '/Home/daniel094144/End-to-end-ASR-Pytorch/spec_augment/party-crowd.wav'

    audio, sr = torchaudio.load(sample)


    #plt.figure()
    #plt.plot(audio.detach().numpy())

    spectro = tfm_spectro(audio, sr)
    tensor_to_img(spectro, 'sp')
    #tensor_to_img(time_warp(spectro))
    tensor_to_img(time_mask(spectro), 'tm')
    tensor_to_img(time_mask(spectro, num_masks=2), '2_tm')
    print(spectro.shape)
    #tensor_to_img(time_warp(spectro), 'tw')

    
    
    tensor_to_img(freq_mask(spectro), 'fm')
    '''